<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>s_plr_mask</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Set by controller
number = 0;
color = c_white;
x_scale = 1;
pad_num = 0;

// Moving
h_speed = 0;
max_hspeed = 5;
acceleration = 0.1;
v_speed = 0;
jump_speed = 10;
fall_speed = 8;
max_jumps = 2;
jumps_remaining = max_jumps;
kickback_speed = 7;

on_ground = false;
bumped = false;
emit_thrust_trail = false;
foot_stepped = false;
landed_on_ground = false;

// Gamepad specific
vibration_left_motor = 0;
vibration_right_motor = 0;

// Missile Collision
// TODO: missile state array
missile_x = 0;
missile_y = 0;
missile_force = 0;
missile_dir = 0;
missile_color = c_white;
stuck = false;

// Shooting
aim_dir = 90;  // incremental change (angle approach)
aim_dir_fixed = aim_dir;  // immediate change
can_shoot = true;
shoot = false;
shoot_mine = false;
miss_type = MISS.bullet;
mine_remote = false;
mines_remaining = 2;
mine_queue = ds_queue_create();

// Alarm Delays (starting from alarm[o])
spawn_crate_delay = 60;
bumped_delay = 40;
emit_thrust_trail_delay = 6;
foot_step_delay = 10;

// Power-Ups
shielded = false;  // TODO: handle; draw low alpha radius if true
can_teleport = false;

x_laser_start = x;
y_laser_start = y;
x_laser_end = x;
y_laser_end = y;

// Drawing
width = sprite_width;
height = sprite_height;
draw_dir = aim_dir;
bobbing_sine = 0;  // bobbing
bobbing_sine_move_inc = 0.7;
bobbing_sine_idle_inc = 0.3;
s_ammo_indicator_alpha = 1; // s_ammo_indicator
s_ammo_indicator_alpha_sine = 0;
s_ammo_indicator_alpha_sine_inc = 0.1;
s_legs_index = s_legs_idle; // s_legs
s_legs_image_index = 0;
s_torso_x_offset = 0; // s_torso
s_torso_y_offset = 0;
s_torso_image_index = 0;
s_arms_y_offset = 0; // s_arms
s_arms_x_offset = 0;
s_arms_y_origin_offset = 6;
s_arms_x_origin_offset = 5;
s_arms_recoil_offset = 6;
s_arms_image_index = 0;
s_arms_origin_to_muzzle_long = 28;
s_arms_origin_to_muzzle_short = 20;
s_gun_overlay_alpha = 1; // s_gun
s_gun_overlay_alpha_sine = 0;
s_gun_overlay_alpha_sine_inc = s_ammo_indicator_alpha_sine_inc;

// Mappings (key &amp; gamepad)
key_map_right = ord("D");
key_map_left = ord("A");
key_map_jump = vk_backspace;
key_map_up = ord("W");
key_map_down = ord("S");
key_map_shoot = vk_space;
key_map_shoot_mine = vk_delete;
key_map_aim_diagonally = vk_shift;
key_map_detonate_mine = vk_control;
key_map_power = vk_enter;

gamepad_set_axis_deadzone(pad_num, 0.2);
gamepad_set_button_threshold(pad_num, 0.1);
button_map_jump = gp_shoulderlb;
button_map_shoot = gp_shoulderrb;
button_map_shoot_mine = gp_shoulderr;
button_map_detonate_mine = gp_stickr;
button_map_power = gp_shoulderl;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Visuals

if (stuck) {
    with (instance_create(x, y, o_stuck_player)) {
        blade_x_offset = other.missile_x - other.x;
        blade_y_offset = other.missile_y - other.y;
        blade_rot = other.missile_rot;
        blade_color = other.missile_color;
        force_dir = other.missile_dir;
        force = other.missile_force;
        color = other.color;
        x_scale = other.x_scale;
        draw_dir = other.draw_dir;
        bobbing_sine = other.bobbing_sine;
        s_legs_index = other.s_legs_index;
        s_legs_image_index = other.s_legs_image_index;
        s_torso_x_offset = other.s_torso_x_offset;
        s_torso_y_offset = other.s_torso_y_offset;
        s_torso_image_index = other.s_torso_image_index;
        s_arms_y_offset = other.s_arms_y_offset;
        s_arms_x_offset = other.s_arms_x_offset;
        s_arms_y_origin_offset = other.s_arms_y_origin_offset;
        s_arms_x_origin_offset = other.s_arms_x_origin_offset;
        s_arms_recoil_offset = other.s_arms_recoil_offset;
        s_arms_image_index = other.s_arms_image_index;
        jumps_remaining = other.jumps_remaining;
    }
}
else {
    var dir = point_direction(missile_x, missile_y, x, y);  // &lt;- for explosion, else missile_dir
    var spread = 45;
    // blood spray
    part_type_colour1(o_part_ctrl.type_missile_hit, color);
    part_type_speed(o_part_ctrl.type_missile_hit, 0, missile_force, 0, 0);
    part_type_direction(o_part_ctrl.type_missile_hit, dir - spread, dir + spread, 0, 0);
    part_emitter_region(o_part_ctrl.system, o_part_ctrl.emitter, x - 8, x + 8, y - 8, y + 8, ps_shape_ellipse, ps_distr_gaussian);
    part_emitter_burst(o_part_ctrl.system, o_part_ctrl.emitter, o_part_ctrl.type_missile_hit, 500);
    // blood splatter
    part_type_colour1(o_part_ctrl.type_blood_decal, color);
    part_type_speed(o_part_ctrl.type_blood_decal, 0, missile_force, 0, 0);
    part_type_direction(o_part_ctrl.type_blood_decal, dir - spread, dir + spread, 0, 0);
    part_emitter_region(o_part_ctrl.system_surf, o_part_ctrl.emitter_surf, x - 8, x + 8, y - 8, y + 8, ps_shape_ellipse, ps_distr_gaussian);
    part_emitter_burst(o_part_ctrl.system_surf, o_part_ctrl.emitter_surf , o_part_ctrl.type_blood_decal, 50);
    
    with (instance_create(x, y, o_gibs)) {
        color = other.color;
        x_scale = other.x_scale;
        force_x = other.missile_x;
        force_y = other.missile_y;
        force = other.missile_force;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sound

audio_play_sound(snd_player_death, 0, false);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Clean up

ds_queue_destroy(mine_queue);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Respawn

o_main_ctrl.alarm[number] = global.respawn_time;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Set gamepad vibration

gamepad_set_vibration(pad_num, 1, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset Vibration

vibration_left_motor = 0;
vibration_right_motor = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// On Foot Step

foot_stepped = false;
audio_sound_pitch(snd_step, 1 + random_range(-0.2, 0.2));
audio_play_sound(snd_step, 0, false);
particle_burst(o_part_ctrl.type_foot_step, 5, c_ltgray, 90, x + random_range(-5, 5), y + sprite_height/2);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// emit_thrust_trail = false;

emit_thrust_trail = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// bumped = false;

bumped = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Spawn crate

if (instance_number(o_ammo_crate) &lt; global.num_players) {
    spawn_crate(o_ammo_crate);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Shoot Missile / Mine

shoot = key_shoot || button_shoot;
shoot_mine = key_shoot_mine || button_shoot_mine;

// set projectile origin
var s_arms_origin_to_muzzle;
if (s_arms_image_index == 0 || s_arms_image_index == 2) {
    s_arms_origin_to_muzzle = s_arms_origin_to_muzzle_long;
}
else {
    s_arms_origin_to_muzzle = s_arms_origin_to_muzzle_short;
}

var x_origin = x - (s_arms_x_origin_offset * x_scale) + lengthdir_x(s_arms_origin_to_muzzle, aim_dir_fixed);
var y_origin = y - s_arms_y_origin_offset + lengthdir_y(s_arms_origin_to_muzzle, aim_dir_fixed);

// Out of bounds check
if ((shoot || shoot_mine) &amp;&amp; 
    (collision_point(x_origin, y_origin, o_collision_wall, false, false) ||
    collision_point(x_origin, y_origin, o_player, false, true))) {
    x_origin = x - (s_arms_x_origin_offset * x_scale);
    y_origin = y - s_arms_y_origin_offset;
}

// MISSILE
if (shoot) {
    if (can_shoot) {
        can_shoot = false;
        with(instance_create(x_origin, y_origin, o_missile)) {
            owner_num = other.number;
            color = other.color;
            direction = other.aim_dir_fixed;
            image_angle = direction;
            type = other.miss_type;
            set_missile_traits(type);
        }
        // gamepad vibration
        vibration_right_motor = 1;
        vibration_left_motor = 1;
        alarm[4] = 10;
        // fire sound
        audio_play_sound(snd_fire_missile, 0, false);
        // muzzle sparks
        particle_burst(o_part_ctrl.type_missile_hit, 20, color, aim_dir_fixed, x_origin, y_origin);
        particle_burst(o_part_ctrl.type_missile_hit, 20, color, 360, x_origin, y_origin);
        // arm_recoil
        s_arms_y_offset = lengthdir_y(s_arms_recoil_offset, aim_dir);
        s_arms_x_offset = lengthdir_x(s_arms_recoil_offset, aim_dir);
        // spawn crate
        alarm[0] = spawn_crate_delay;
    }
    else {
        // dry fire
        audio_play_sound(snd_dry_fire, 0, false);
        particle_burst(o_part_ctrl.type_missile_hit, 20, color, 360, x_origin, y_origin);
    }
}

// MINE
if (shoot_mine) {
    if (mines_remaining == 0) {
        with(ds_queue_dequeue(mine_queue)) {
            instance_destroy();
        }
        mines_remaining++;
    }
    with(instance_create(x_origin, y_origin, o_mine)) {
        ds_queue_enqueue(other.mine_queue, id);
        owner_id = other.id;
        rotate_dir = -other.x_scale;
        color = other.color;
        direction = other.aim_dir_fixed;
        image_angle = direction;
        remote = other.mine_remote;
        if (remote) {
            sprite_index = s_mine_remote;
        }
    }
    mines_remaining--;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Drawing

if (can_shoot) {
    // Ammo indicator (missile type)
    s_ammo_indicator_alpha_sine += s_ammo_indicator_alpha_sine_inc;
    s_ammo_indicator_alpha = 0.75 + sin(s_ammo_indicator_alpha_sine) * 0.25;
    // Gun
    s_gun_overlay_alpha_sine += s_gun_overlay_alpha_sine_inc;
    s_gun_overlay_alpha = 0.5 + sin(s_gun_overlay_alpha_sine) * 0.5;
}
else {
    s_ammo_indicator_alpha = 1;
    s_gun_overlay_alpha = 1;
}

// Legs and Bobbing
if (move != 0 &amp;&amp; v_speed == 0) { 
    s_legs_image_index += 0.5;
    s_legs_index = s_legs_move;
    s_torso_x_offset = x_scale * 3;
    s_torso_y_offset = sin(bobbing_sine);  // move bobbing
    bobbing_sine += bobbing_sine_move_inc; 
}
else {
    s_legs_index = s_legs_idle;
    s_torso_x_offset = 0;
    if (!on_ground) {
        s_legs_image_index = 1;  // legs in air
        if (v_speed &lt; 0 &amp;&amp; s_torso_y_offset &gt; -2) {
            s_torso_y_offset -= 0.5;
        }
        if (v_speed &gt; 0 &amp;&amp; s_torso_y_offset &lt; 2) {
            s_torso_y_offset += 0.5;
        }
        bobbing_sine = pi/2; // land with highest y offset
    }
    else {
        s_legs_image_index = 0;
        s_torso_y_offset = sin(bobbing_sine);  // idle bobbing
        bobbing_sine += bobbing_sine_idle_inc;
    }
}

// Torso
if (bumped) {
    s_torso_image_index = 3;
}
else {
    if (aim_dir_fixed == 90 || aim_dir_fixed == 90 - x_scale * 45) {
        s_torso_image_index = 1;
    }
    else if (aim_dir_fixed == 270 || aim_dir_fixed == 270 + x_scale * 45) {
        s_torso_image_index = 2;
    }
    else {
        s_torso_image_index = 0;
    }
}

// Arms
if (shoot_mine) {
    s_arms_y_offset = lengthdir_y(s_arms_recoil_offset, aim_dir); // recoil
    s_arms_x_offset = lengthdir_x(s_arms_recoil_offset, aim_dir);
}
s_arms_y_offset = lerp(s_arms_y_offset, 0, 0.1);  // return to origin
s_arms_x_offset = lerp(s_arms_x_offset, 0, 0.1);

if (aim_dir == 270 + x_scale * 45 || aim_dir == 90 - x_scale * 45) {
    draw_dir = 0;
}
else {
    draw_dir = aim_dir - 90 * abs(x_scale - 1);
}

if (aim_dir == 90 || aim_dir == 270) {
    s_arms_image_index = 1;
}
else if (aim_dir == 270 + x_scale * 45) {
    s_arms_image_index = 3;
    draw_dir -= 90 * x_scale;
}
else if (aim_dir == 90 - x_scale * 45) {
    s_arms_image_index = 2;
}
else {
    s_arms_image_index = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Laser Power-Up
/*
var laser_dist_check = 0;
x_laser_start = x - s_arms_x_origin_offset * x_scale - 1 + s_torso_x_offset;
y_laser_start = y - s_arms_y_origin_offset + s_torso_y_offset;
x_laser_end = x_laser_start + lengthdir_x(room_width, aim_dir);
y_laser_end = y_laser_start + lengthdir_y(room_width, aim_dir);

/*
//TODO: var collider = collision_func(o_collider); object_get_name(collider) == ?
if (miss_type != MISS.blade) {
    //var wall = collision_line_first(x_laser_start, y_laser_start, x_laser_end, y_laser_end, o_collision_wall, true, false);
    var player = collision_line_first(x_laser_start, y_laser_start, x_laser_end, y_laser_end, o_player, false, true);
    
    if (player) {
        var dist;
        with (player) {          
            dist = distance_to_point(other.x_laser_start, other.y_laser_start);
        }
        x_laser_end = x_laser_start + lengthdir_x(dist, aim_dir);
        y_laser_end = y_laser_start + lengthdir_y(dist, aim_dir);
    }
}    
/*
if (!collision_point(x_laser_end, y_laser_end, o_collision_wall, true, false) &amp;&amp;
    !collision_point(x_laser_end, y_laser_end, o_player, false, true)) {
    do {
        laser_dist_check++;
        x_laser_end += lengthdir_x(laser_dist_check, aim_dir);
        y_laser_end += lengthdir_y(laser_dist_check, aim_dir);
    } until (
        collision_point(x_laser_end, y_laser_end, o_collision_wall, true, false) ||
        collision_point(x_laser_end, y_laser_end, o_player, false, true) ||
        x_laser_end &lt;= 0 || x_laser_end &gt;= room_width ||
        y_laser_end &lt;= 0 || y_laser_end &gt;= room_height 
    );
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Emit Thrust Trail

if (emit_thrust_trail) {
    particle_burst(o_part_ctrl.type_thrust, 10, color, 270, x - 10 * x_scale, y);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Key / Gamepad Checks

key_right = keyboard_check(key_map_right);
key_left = -keyboard_check(key_map_left);
key_jump = keyboard_check_pressed(key_map_jump);
key_up = keyboard_check(key_map_up);
key_down = keyboard_check(key_map_down);
key_aim_diagonally = keyboard_check(key_map_aim_diagonally);
key_shoot = keyboard_check_pressed(key_map_shoot);
key_shoot_mine = keyboard_check_pressed(key_map_shoot_mine);

pad_h_axis = gamepad_axis_value(pad_num, gp_axislh);
pad_v_axis = gamepad_axis_value(pad_num, gp_axisrv);
button_jump = gamepad_button_check_pressed(pad_num, button_map_jump);
button_shoot = gamepad_button_check_pressed(pad_num, button_map_shoot);
button_shoot_mine = gamepad_button_check_pressed(pad_num, button_map_shoot_mine);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement &amp; Collisions

var shoot = (key_shoot || button_shoot) &amp;&amp; can_shoot

// Horizontal
move = key_left + key_right;
if (pad_h_axis != 0) {
    move = sign(pad_h_axis) * abs(ceil(pad_h_axis));
}

h_speed = lerp(h_speed, move * max_hspeed, acceleration);
if (shoot) {
    h_speed = -cos(degtorad(aim_dir_fixed)) * kickback_speed;
}

if (move != 0) {
    x_scale = move;
    if (!foot_stepped &amp;&amp; on_ground) {
        foot_stepped = true;
        alarm[3] = foot_step_delay;
    }
}

if (place_meeting(x + h_speed, y, o_collision_wall)) {
    while (!place_meeting(x + sign(h_speed), y, o_collision_wall)) {
        x += sign(h_speed);
    }
    h_speed = 0;
}
x += h_speed;

// Vertical
v_speed = lerp(v_speed, fall_speed, global.player_grav);
if (shoot) {
    v_speed = sin(degtorad(aim_dir_fixed)) * kickback_speed;
}
if ((key_jump || button_jump) &amp;&amp; jumps_remaining &gt; 0) {
    player_jump();
}

if (place_meeting(x, y + v_speed, o_collision_wall)) {
    while (!place_meeting(x, y + sign(v_speed), o_collision_wall)) {
        y += sign(v_speed);
    }
    v_speed = 0;
}
y += v_speed;

if (place_meeting(x, y + 1, o_collision_wall)) {
    on_ground = true;
    jumps_remaining = max_jumps;
    if (!landed_on_ground) {
        landed_on_ground = true;
        var y_region = y + sprite_height/2;
        particle_burst(o_part_ctrl.type_foot_step, 5, c_ltgray, 90, x + 5, y_region);
        particle_burst(o_part_ctrl.type_foot_step, 5, c_ltgray, 90, x - 5, y_region);
        audio_play_sound(snd_step, 0, false);
    }
}
else {
    on_ground = false;
    landed_on_ground = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Aiming

var aim_diagonally = key_aim_diagonally;
var pad_diagonal_threshold = 0.9999;
if (aim_diagonally == 0 &amp;&amp; abs(pad_v_axis) &lt; pad_diagonal_threshold &amp;&amp; abs(pad_v_axis) &gt; 0) { 
    aim_diagonally = 1;
}

if (key_up || pad_v_axis &lt; 0) {
    aim_dir_fixed = 90 - (aim_diagonally * sign(x_scale) * 45); 
}
else if ((key_down || pad_v_axis &gt; 0)) {
    //if (!on_ground) {
        aim_dir_fixed = 270 + (aim_diagonally * sign(x_scale) * 45);
    /*}
    else {
        aim_dir_fixed = 270 + sign(x_scale) * 45;
    }*/
}
else {
    if (x_scale == 1) {
        aim_dir_fixed = 0;
    }
    else if (x_scale == -1) {
        aim_dir_fixed = 180;
    }
}

if (abs(angle_difference(aim_dir, aim_dir_fixed)) &gt; 45) {
    turn_speed = 24;
}
else {
    turn_speed = 12;
}
aim_dir = angle_approach(aim_dir, aim_dir_fixed, turn_speed);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal Screen wrap

if (x &lt; 0) {
    x = room_width;
}

if (x &gt; room_width) {
    x = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Gamepad Vibration

gamepad_set_vibration(pad_num, vibration_left_motor, vibration_right_motor);

if (alarm[4] == -1 &amp;&amp; vibration_left_motor &gt; 0 &amp;&amp; vibration_right_motor &gt; 0) {
    // fade
    vibration_left_motor = lerp(vibration_left_motor, 0, 0.1);
    vibration_right_motor = lerp(vibration_right_motor, 0, 0.1);
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// (Debug) Cycle, can_shoot

// Missile Type
if (keyboard_check_pressed(vk_anykey)) {
    var key = real(chr(keyboard_key)) - 1;
    if (key &gt;= 0 &amp;&amp; key &lt; MISS.LAST) {
        miss_type = key;
    }
}

// Color
if (keyboard_check_pressed(vk_tab)) {
    color_index++;
    color = global.colors[color_index % 4];
}

// Can Shoot
if(keyboard_check_pressed(ord("0"))) {
    can_shoot = !can_shoot;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="o_ammo_crate">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!can_shoot) {
    miss_type = other.type;
    can_shoot = true;
    with (other) {
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="o_player">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Bump

var dir = point_direction(other.x, other.y, x, y);

h_speed = lengthdir_x(kickback_speed, dir);
v_speed = lengthdir_y(kickback_speed, dir);

vibration_right_motor = 1;
vibration_left_motor = 1;
alarm[4] = 10;

bumped = true;
alarm[1] = bumped_delay;

audio_sound_pitch(snd_bump, 1 + random_range(-0.4, 0.4));
audio_play_sound(snd_bump, 0, false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Laser
/*
draw_set_colour(c_red);
draw_set_alpha(0.3);
draw_line_width(x_laser_start, y_laser_start, x_laser_end, y_laser_end, 2);
draw_set_alpha(1);
*/

// Missile Type
if (can_shoot) {
    draw_sprite_ext(s_ammo_indicator, miss_type, x, y - 24, 1, 1, 0, color, s_ammo_indicator_alpha);
}

// Torso
draw_sprite_ext(s_torso, s_torso_image_index, x + s_torso_x_offset,
    y + s_torso_y_offset, x_scale, 1, 0, color, 1);

// Jetpack
draw_sprite_ext(s_jetpack, jumps_remaining, x + s_torso_x_offset, y + s_torso_y_offset, x_scale, 1, 0, color, 1);

// Legs
draw_sprite_ext(s_legs_index, s_legs_image_index, x, y, x_scale, 1, 0, color, 1);

// Gun
draw_sprite_ext(s_gun, s_arms_image_index, x - (5 * x_scale) + s_torso_x_offset - s_arms_x_offset,
    y - 6 + s_torso_y_offset - s_arms_y_offset, x_scale, 1, draw_dir, color, 1);

if (can_shoot) { 
    draw_sprite_ext(s_gun_overlay, s_arms_image_index, x - (5 * x_scale) + s_torso_x_offset - s_arms_x_offset,
    y - 6 + s_torso_y_offset - s_arms_y_offset, x_scale, 1, draw_dir, color, s_gun_overlay_alpha);
}

// Arms
draw_sprite_ext(s_arms, s_arms_image_index, x - (5 * x_scale) + s_torso_x_offset - s_arms_x_offset,
    y - 6 + s_torso_y_offset - s_arms_y_offset, x_scale, 1, draw_dir, color, 1);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debug

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
